"use strict";

// 1. Для практикума из занятия 7 продумать, где можно применить замыкания.

/*
У меня есть такая идея:
Применить каррирование функции. По сути это функция, в которой есть вторая функция и она основная логика сработает, когда во внутреннюю функцию прилетит значение. Где-бы я это применил. 


*/
// старый метод
// canSetDirection(direction) {
//     const lastStepDirection = this.snake.getLastStepDirection();

//     return direction === 'up' && lastStepDirection !== 'down' ||
//         direction === 'right' && lastStepDirection !== 'left' ||
//         direction === 'down' && lastStepDirection !== 'up' ||
//         direction === 'left' && lastStepDirection !== 'right';
// };
// метод с каррированием
canSetDirection(direction) {
    return function (lastStepDirection) {
        return direction === 'up' && lastStepDirection !== 'down' ||
            direction === 'right' && lastStepDirection !== 'left' ||
            direction === 'down' && lastStepDirection !== 'up' ||
            direction === 'left' && lastStepDirection !== 'right';
    }
}
// место где вызываем
keyDownHandler(event) {
    if (!this.status.isPlaying()) return;

    const direction = this.getDirectionByCode(event.code);
    const lastStepDirection = this.snake.getLastStepDirection();

    if (this.canSetDirection(direction)(lastStepDirection)) this.snake.setDirection(direction);
}

// Данный пример я считаю не нужным в плане надобности, но механизм я применил по сути.

// 2. Не выполняя кода, ответить, что выведет браузер и почему:

if (!("a" in window)) {
    var a = 1;
}
alert(a);

/*
Ответ: undefined. Потому что ! это отрицание. Из-за этого отрицания условие не выполниться и глобальная переменная var a была создана, но у неё нет присвоенного значения вообще. Поэтому она выдаёт undefined при её вызове.
*/

var b = function a(x) {
    x && a(--x);
};

alert(a);

/*
Ответ: a is not defined. Подобного рода сообщение выдаётся когда к переменной, к которой обращаемся не существует вообще либо когда она в не зоны видимости находится. В данном случае у нас будет переменная b которой присвоена функция с названием a. Но обратьться к нему из вне увы не получиться. Максимум что получиться это b().a - undefined. Если же мы обратимся к b и в функции пропишем return a, то мы вернём фсю функцию с её телом. Довольно интересное поведение. Не знаю зачем может пригодиться возврат функции с телом пока что. На мой взгляд не требуется задавать функции дополнительное имя так как мы и так можем получить внутри функции доступ к значению x, а внешне обращаться к названию переменной b чтоб вызвать эту функцию и положить в неё значение.
*/

function a(x) {
    return x * 2;
}
var a;
alert(a);

/*
Ответ: function a(x) {
    return x * 2;
}
Вернётся функция вместе с её телом. Так как значение перемнной a не было присвоено, то в значением переменной a осталось функция, которая носила то же название. Это произошло так как у функции и новой переменной одинаковые имена. Эти имена по сути это ссылки на сами данные. Еслиб значение перемнной было присвоено, то функция-бы затёрлась.
*/

function b(x, y, a) {
    arguments[2] = 10;
    alert(a);
}
b(1, 2, 3);

/*
Ответ: 3. Поведение очень интересно. Если мы будем выводить arguments[0] - 1, arguments[1] - 2, arguments[2] - 10. Четвёртого индекса там уже не будет. Я делаю вывод что список аргументов, не влияет напрямую на значения параметров переменных. Тоесть параметр с именем а (по сути переменная функции) никак не затрёт своё значение если мы поменяем значение списка аргументов функции. Получается так что значения параметров попадают в этот список по порядку и всё. По сути работает всё правильно так как и у обычного списка нет власти над значениями перемнных. В них просто можно добавить это значение, а изменить значение перемнной списки не в состоянии естественно.
*/

function a() {
    alert(this);
}

a.call(null);

/*
Ответ: null. Метод call определяет контекст для функции. По сути туда нужно передавать объект, который должен использоваться функцией. Мы туда передали null поэтому наша функция его и вернула. Таким образом мы можем работать с объектом в функции не передавая параметры в неё саму через её параметр, а используя call. Далее мы можем использовать объект через this.name. Конечно при этом надо будет передать нормальный объект, а не null.
*/

/*
P.S. Спасибо что учили нас. Было интересно выполнять ваши домашние задания. Жаль что я некоторые доп задания я не успел выполнить. И не говорите что мы вас терпим. Вы хороший учитель. Все доброго и удачи вам на вашем пути учителя). И ещё я выполнял код так как я так лучше понимаю что происходит с программой).
*/
